<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ImageNet Hierarchy Explorer</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body { font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; overflow: hidden; height: 100vh; }
        #app-container { height: 100%; display: flex; flex-direction: column; }
        
        /* Toolbar */
        #toolbar { border-bottom: 1px solid #ddd; padding: 10px; background: #f8f9fa; z-index: 10; }
        
        /* Main Layout */
        #main-area { flex: 1; display: flex; overflow: hidden; position: relative; }
        
        /* Visualization */
        #viz-container { flex: 1; overflow: hidden; background: #fff; cursor: grab; position: relative; }
        #viz-container:active { cursor: grabbing; }

        /* Sidebar/Details */
        #sidebar { width: 300px; border-left: 1px solid #ddd; background: #fff; display: flex; flex-direction: column; z-index: 5; box-shadow: -2px 0 5px rgba(0,0,0,0.05); }
        #details-pane { padding: 20px; flex: 1; overflow-y: auto; }
        #search-results { flex: 1; overflow-y: auto; border-top: 1px solid #eee; display: none; }
        .search-item { padding: 8px 15px; cursor: pointer; border-bottom: 1px solid #f0f0f0; font-size: 0.9em; }
        .search-item:hover { background-color: #e9ecef; }

        /* D3 Styles */
        .node circle { fill: #999; stroke: #fff; stroke-width: 2px; transition: all 0.3s; }
        .node text { font: 12px sans-serif; text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff; pointer-events: none;}
        .link { fill: none; stroke: #ccc; stroke-width: 1.5px; opacity: 0.6; }
        
        /* Node Types */
        .node--internal circle { fill: #ccc; r: 4; }
        .node--class circle { fill: #0d6efd; r: 6; stroke: #004085; } /* Bootstrap Primary Blue */
        .node--class:hover circle { r: 9; fill: #ffc107; } /* Pop on hover */
        .node--selected circle { fill: #dc3545 !important; r: 8; stroke: #842029; } /* Red highlight */

        /* Loading Overlay */
        #loading { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.9); z-index: 1000; display: none; align-items: center; justify-content: center; flex-direction: column; }
    </style>
</head>
<body>

<div id="loading">
    <div class="spinner-border text-primary" role="status"></div>
    <div class="mt-2 text-muted">Processing Hierarchy...</div>
</div>

<div id="app-container">
    <div id="toolbar" class="d-flex align-items-center gap-3">
        <div class="d-flex align-items-center">
            <label class="btn btn-outline-secondary btn-sm me-2">
                Upload JSON <input type="file" id="fileInput" accept=".json" hidden>
            </label>
            <span id="file-status" class="text-muted small">No file loaded</span>
        </div>
        
        <div class="flex-grow-1 position-relative">
            <input type="text" id="searchInput" class="form-control form-control-sm" placeholder="Search Synset ID (e.g., 'kit_fox')..." disabled>
        </div>
        
        <div class="btn-group btn-group-sm">
            <button class="btn btn-outline-secondary" onclick="expandAll()">Expand All</button>
            <button class="btn btn-outline-secondary" onclick="collapseAll()">Collapse All</button>
        </div>
    </div>

    <div id="main-area">
        <div id="viz-container"></div>
        
        <div id="sidebar">
            <div id="details-pane">
                <h5 class="border-bottom pb-2">Node Details</h5>
                <div id="node-info" class="text-muted small">
                    Select a node to view details.
                </div>
            </div>
            <div id="search-results-container" style="display:none; flex-direction:column; height: 50%; border-top: 1px solid #ddd;">
                <div class="bg-light p-2 small font-weight-bold border-bottom">Search Results</div>
                <div id="search-results"></div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- Global State ---
    let rootData = null;
    let d3Root = null;
    let svg, g, zoom;
    let width, height;
    let idToMeta = {}; // Map rid -> { sid, class_id }
    let nodeLookup = {}; // Map rid -> [d3Node, d3Node...] (One rid can appear multiple times in Tree view)
    let i = 0;
    const duration = 750;

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        width = document.getElementById('viz-container').offsetWidth;
        height = document.getElementById('viz-container').offsetHeight;

        // Setup SVG
        svg = d3.select("#viz-container").append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .call(d3.zoom().scaleExtent([0.1, 8]).on("zoom", (e) => {
                g.attr("transform", e.transform);
            }))
            .on("dblclick.zoom", null); // Disable double click zoom
        
        g = svg.append("g").attr("transform", "translate(100,0)"); // Initial offset
        
        // Handle Window Resize
        window.addEventListener('resize', () => {
            width = document.getElementById('viz-container').offsetWidth;
            height = document.getElementById('viz-container').offsetHeight;
            update(d3Root);
        });

        // Event Listeners
        document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        document.getElementById('searchInput').addEventListener('input', handleSearch);
    });

    // --- Data Processing ---
    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        document.getElementById('loading').style.display = 'flex';
        document.getElementById('file-status').textContent = file.name;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const rawData = JSON.parse(e.target.result);
                processData(rawData);
                document.getElementById('searchInput').disabled = false;
                document.getElementById('loading').style.display = 'none';
            } catch (err) {
                alert("Error parsing JSON: " + err.message);
                document.getElementById('loading').style.display = 'none';
            }
        };
        reader.readAsText(file);
    }

    function processData(data) {
        // 1. Build Metadata Map (RID -> Info)
        idToMeta = {};
        const count = data.rid.length;
        
        for (let idx = 0; idx < count; idx++) {
            idToMeta[data.rid[idx]] = {
                sid: data.sid[idx],
                class_id: data.ilsvrc_class_id[idx]
            };
        }

        // 2. Build Tree Structure
        // Since input is a list of paths, we merge them into a single tree object.
        // We assume root is usually rid=1 (Entity), but we'll handle generic starts.
        let treeMap = new Map(); // Map<rid, NodeObject>
        let rootNode = { name: "Root", children: [], rid: -1, isVirtual: true };

        // Helper to get or create a node object
        function getOrCreateNode(rid, parent) {
            // In a strict Tree Visualization of a DAG, nodes appear multiple times.
            // However, to build the data structure for D3 hierarchy, we usually build a strict tree object.
            // But we can't share objects in d3.hierarchy if we want them to have different parents visually.
            // So we traverse the path and build a unique tree structure.
            return {
                rid: rid,
                name: idToMeta[rid] ? idToMeta[rid].sid : `ID: ${rid}`,
                class_id: idToMeta[rid] ? idToMeta[rid].class_id : -1,
                children: []
            };
        }

        // Since this is a DAG presented as paths, we can construct the tree by simply 
        // merging paths starting from the root.
        // We need a root for the D3 tree. We'll try to find the common ancestor or use a virtual root.
        
        let visualRoot = { name: "World", children: [], rid: 0, class_id: -1 };
        
        // We use a recursive merge strategy.
        // We cannot use a simple ID map for nodes because node 'A' might be under 'B' in one path and 'C' in another.
        // D3 hierarchy needs distinct objects for the tree layout.
        
        // To optimize, we sort paths by length so we build top-down? 
        // Actually, simply inserting every path into a tree structure works.
        
        for (let idx = 0; idx < count; idx++) {
            const path = data.path_rid[idx];
            let currentLevel = visualRoot.children;
            
            // Skip the first element if it matches our virtual root logic, but here we just take the path as is.
            for (let p = 0; p < path.length; p++) {
                const rid = path[p];
                
                // Check if this rid already exists at this specific level
                let existingNode = currentLevel.find(n => n.rid === rid);
                
                if (!existingNode) {
                    existingNode = {
                        rid: rid,
                        name: idToMeta[rid] ? idToMeta[rid].sid : `Unknown (${rid})`,
                        class_id: idToMeta[rid] ? idToMeta[rid].class_id : -1,
                        _children: null, // Temp storage for collapse state
                        children: []
                    };
                    currentLevel.push(existingNode);
                }
                
                // Move down
                currentLevel = existingNode.children;
            }
        }

        // Clean up: If virtual root has only 1 child (e.g., 'Entity'), make that the root to save space
        if (visualRoot.children.length === 1) {
            rootData = visualRoot.children[0];
        } else {
            rootData = visualRoot;
        }

        initD3(rootData);
    }

    // --- D3 Visualization ---
    function initD3(data) {
        g.selectAll("*").remove(); // Clear canvas
        nodeLookup = {}; // Reset lookup

        d3Root = d3.hierarchy(data, d => d.children);
        d3Root.x0 = height / 2;
        d3Root.y0 = 0;

        // Pre-process to populate lookup for search
        d3Root.descendants().forEach(d => {
            if (!nodeLookup[d.data.rid]) nodeLookup[d.data.rid] = [];
            nodeLookup[d.data.rid].push(d);
            
            // Initial state: Collapse everything below depth 1 or 2
            if (d.depth > 1) {
                d._children = d.children;
                d.children = null;
            }
        });

        update(d3Root);
    }

    function update(source) {
        // Compute the new tree layout.
        const treeLayout = d3.tree().nodeSize([20, 150]); // Node height, Level width
        const treeData = treeLayout(d3Root);

        // Compute the new tree layout.
        const nodes = treeData.descendants();
        const links = treeData.links();

        // Normalize for fixed-depth.
        nodes.forEach(d => { d.y = d.depth * 180; });

        // ****************** Nodes section ***************************

        const node = g.selectAll('g.node')
            .data(nodes, d => d.id || (d.id = ++i));

        const nodeEnter = node.enter().append('g')
            .attr('class', d => {
                const type = d.data.class_id >= 0 ? 'node--class' : 'node--internal';
                return `node ${type}`;
            })
            .attr("transform", d => `translate(${source.y0},${source.x0})`)
            .on('click', click)
            .on('mouseover', showDetails);

        nodeEnter.append('circle')
            .attr('class', 'node-circle')
            .attr('r', 1e-6)
            .style("fill", d => d._children ? "#555" : (d.data.class_id >= 0 ? "#0d6efd" : "#fff"));

        nodeEnter.append('text')
            .attr("dy", ".35em")
            .attr("x", d => d.children || d._children ? -13 : 13)
            .attr("text-anchor", d => d.children || d._children ? "end" : "start")
            .text(d => d.data.name)
            .style("fill-opacity", 1e-6);

        // UPDATE
        const nodeUpdate = node.merge(nodeEnter);

        nodeUpdate.transition()
            .duration(duration)
            .attr("transform", d => `translate(${d.y},${d.x})`);

        nodeUpdate.select('circle.node-circle')
            .attr('r', d => d.data.class_id >= 0 ? 6 : 4.5)
            .style("fill", d => {
                if(d.data.selected) return "#dc3545"; // Selected
                if(d.data.class_id >= 0) return "#0d6efd"; // ImageNet Class
                return d._children ? "#999" : "#fff"; // Internal
            })
            .style("stroke", d => d.data.selected ? "#842029" : (d.data.class_id >= 0 ? "#004085" : "#999"))
            .attr('cursor', 'pointer');

        nodeUpdate.select('text')
            .style("fill-opacity", 1);

        // EXIT
        const nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", d => `translate(${source.y},${source.x})`)
            .remove();

        nodeExit.select('circle')
            .attr('r', 1e-6);

        nodeExit.select('text')
            .style("fill-opacity", 1e-6);

        // ****************** Links section ***************************

        const link = g.selectAll('path.link')
            .data(links, d => d.target.id);

        const linkEnter = link.enter().insert('path', "g")
            .attr("class", "link")
            .attr('d', d => {
                const o = {x: source.x0, y: source.y0};
                return diagonal(o, o);
            });

        const linkUpdate = link.merge(linkEnter);

        linkUpdate.transition()
            .duration(duration)
            .attr('d', d => diagonal(d.source, d.target));

        const linkExit = link.exit().transition()
            .duration(duration)
            .attr('d', d => {
                const o = {x: source.x, y: source.y};
                return diagonal(o, o);
            })
            .remove();

        // Stash the old positions for transition.
        nodes.forEach(d => {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    function diagonal(s, d) {
        return `M ${s.y} ${s.x}
                C ${(s.y + d.y) / 2} ${s.x},
                  ${(s.y + d.y) / 2} ${d.x},
                  ${d.y} ${d.x}`;
    }

    function click(event, d) {
        if (d.children) {
            d._children = d.children;
            d.children = null;
        } else {
            d.children = d._children;
            d._children = null;
        }
        update(d);
        showDetails(event, d);
    }

    // --- Interaction & Utils ---

    function showDetails(event, d) {
        const infoDiv = document.getElementById('node-info');
        const isClass = d.data.class_id >= 0;
        
        infoDiv.innerHTML = `
            <h6 class="text-dark">${d.data.name}</h6>
            <table class="table table-sm table-borderless small">
                <tr><td class="text-muted">RID:</td><td>${d.data.rid}</td></tr>
                <tr><td class="text-muted">Type:</td><td>
                    <span class="badge ${isClass ? 'bg-primary' : 'bg-secondary'}">
                        ${isClass ? 'ImageNet Class' : 'Internal Node'}
                    </span>
                </td></tr>
                ${isClass ? `<tr><td class="text-muted">Class ID:</td><td>${d.data.class_id}</td></tr>` : ''}
                <tr><td class="text-muted">Depth:</td><td>${d.depth}</td></tr>
            </table>
        `;
    }

    function handleSearch() {
        const query = document.getElementById('searchInput').value.toLowerCase();
        const resultsContainer = document.getElementById('search-results');
        const container = document.getElementById('search-results-container');
        
        resultsContainer.innerHTML = '';
        
        if (query.length < 2) {
            container.style.display = 'none';
            return;
        }

        // Search in ID map
        const matches = [];
        for (const [rid, meta] of Object.entries(idToMeta)) {
            if (meta.sid.toLowerCase().includes(query)) {
                matches.push({ rid: parseInt(rid), sid: meta.sid, cid: meta.class_id });
            }
        }

        if (matches.length > 0) {
            container.style.display = 'flex';
            matches.slice(0, 20).forEach(m => {
                const div = document.createElement('div');
                div.className = 'search-item';
                div.innerHTML = `<strong>${m.sid}</strong> <span class="text-muted text-xs">(${m.rid})</span>`;
                div.onclick = () => selectNode(m.rid);
                resultsContainer.appendChild(div);
            });
        } else {
            container.style.display = 'none';
        }
    }

    function selectNode(rid) {
        // Find d3 nodes corresponding to this rid (could be multiple due to DAG)
        const targets = nodeLookup[rid];
        if (!targets || targets.length === 0) return;

        // Pick the first occurrence or handle multiple (currently picks first)
        const target = targets[0];

        // 1. Expand all parents recursively
        let ancestor = target.parent;
        while(ancestor) {
            if(ancestor._children) {
                ancestor.children = ancestor._children;
                ancestor._children = null;
            }
            ancestor = ancestor.parent;
        }

        // 2. Mark selected
        // Clear previous selection
        d3Root.descendants().forEach(d => d.data.selected = false);
        target.data.selected = true;

        // 3. Update Visuals
        update(d3Root);

        // 4. Pan to node
        // Transform logic to center the node
        const transform = d3.zoomIdentity
            .translate(width / 2 - target.y, height / 2 - target.x)
            .scale(1); // Standard scale
        
        svg.transition().duration(750).call(zoom.transform, transform);
        
        showDetails(null, target);
    }

    function expandAll() {
        if(!d3Root) return;
        d3Root.descendants().forEach(d => {
            if(d._children) {
                d.children = d._children;
                d._children = null;
            }
        });
        update(d3Root);
    }

    function collapseAll() {
        if(!d3Root) return;
        d3Root.descendants().forEach(d => {
            if(d.depth > 0 && d.children) {
                d._children = d.children;
                d.children = null;
            }
        });
        update(d3Root);
    }
</script>
</body>
</html>
