<!-- https://gemini.google.com/app/e545eef66f420855 -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ImageNet Hierarchy Explorer</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <!-- D3.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body { font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; overflow: hidden; height: 100vh; }
        #app-container { height: 100%; display: flex; flex-direction: column; }
        
        /* Toolbar */
        #toolbar { border-bottom: 1px solid #ddd; padding: 10px; background: #f8f9fa; z-index: 10; }
        
        /* Main Layout */
        #main-area { flex: 1; display: flex; overflow: hidden; position: relative; }
        
        /* Visualization */
        #viz-container { flex: 1; overflow: hidden; background: #fff; cursor: grab; position: relative; }
        #viz-container:active { cursor: grabbing; }

        /* Sidebar/Details */
        #sidebar { width: 300px; border-left: 1px solid #ddd; background: #fff; display: flex; flex-direction: column; z-index: 5; box-shadow: -2px 0 5px rgba(0,0,0,0.05); }
        
        /* Updated Sidebar Layout for Search */
        #details-pane { padding: 20px; flex: 1; overflow-y: auto; min-height: 0; }
        #search-results-container { 
            display: none; /* Hidden by default */
            flex-direction: column; 
            border-top: 1px solid #ddd; 
            flex: 1; /* Takes 50% height when visible because details-pane is also flex:1 */
            min-height: 0; 
            background: #fff;
        }
        
        #search-results { flex: 1; overflow-y: auto; }
        .search-item { padding: 8px 15px; cursor: pointer; border-bottom: 1px solid #f0f0f0; font-size: 0.9em; }
        .search-item:hover { background-color: #e9ecef; }

        /* D3 Styles */
        .node circle { fill: #999; stroke: #fff; stroke-width: 2px; transition: all 0.3s; }
        .node text { font: 12px sans-serif; text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff; pointer-events: none;}
        .link { fill: none; stroke: #ccc; stroke-width: 1.5px; opacity: 0.6; }
        
        /* Node Types */
        .node--internal circle { fill: #ccc; r: 4; }
        .node--class circle { fill: #0d6efd; r: 6; stroke: #004085; } /* Bootstrap Primary Blue */
        .node--class:hover circle { r: 9; fill: #ffc107; } /* Pop on hover */
        .node--selected circle { fill: #dc3545 !important; r: 8; stroke: #842029; } /* Red highlight */

        /* Loading Overlay */
        #loading { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.9); z-index: 1000; display: none; align-items: center; justify-content: center; flex-direction: column; }
    </style>
</head>
<body>

<div id="loading">
    <div class="spinner-border text-primary" role="status"></div>
    <div class="mt-2 text-muted">Processing Hierarchy...</div>
</div>

<div id="app-container">
    <!-- Toolbar -->
    <div id="toolbar" class="d-flex align-items-center gap-3">
        <div class="d-flex align-items-center">
            <label class="btn btn-outline-secondary btn-sm me-2">
                Upload JSON <input type="file" id="fileInput" accept=".json" hidden>
            </label>
            <span id="file-status" class="text-muted small">No file loaded</span>
        </div>
        
        <div class="flex-grow-1 position-relative">
            <input type="text" id="searchInput" class="form-control form-control-sm" placeholder="Search Synset ID (e.g., 'kit_fox')..." disabled>
        </div>
        
        <div class="btn-group btn-group-sm">
            <button class="btn btn-outline-secondary" onclick="expandAll()">Expand All</button>
            <button class="btn btn-outline-secondary" onclick="collapseAll()">Collapse All</button>
        </div>
    </div>

    <!-- Main Content -->
    <div id="main-area">
        <div id="viz-container"></div>
        
        <div id="sidebar">
            <div id="details-pane">
                <h5 class="border-bottom pb-2">Node Details</h5>
                <div id="node-info" class="text-muted small">
                    Select a node to view details.
                </div>
            </div>
            <!-- Removed inline style height to rely on CSS flex -->
            <div id="search-results-container">
                <div class="bg-light p-2 small font-weight-bold border-bottom d-flex justify-content-between align-items-center">
                    <span>Search Results</span>
                    <span id="result-count" class="badge bg-secondary">0</span>
                </div>
                <div id="search-results"></div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- Global State ---
    let rootData = null;
    let d3Root = null;
    let svg, g, zoom;
    let width, height;
    let idToMeta = {}; // Map rid -> { sid, class_id }
    let nodeLookup = {}; // Map rid -> [d3Node, d3Node...]
    let i = 0;
    const duration = 750;

    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        width = document.getElementById('viz-container').offsetWidth;
        height = document.getElementById('viz-container').offsetHeight;

        // Initialize zoom behavior first and assign to global variable
        zoom = d3.zoom()
            .scaleExtent([0.1, 8])
            .on("zoom", (e) => {
                g.attr("transform", e.transform);
            });

        // Setup SVG
        svg = d3.select("#viz-container").append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .call(zoom) // Apply zoom behavior
            .on("dblclick.zoom", null); // Disable double click zoom
        
        g = svg.append("g").attr("transform", "translate(100,0)"); // Initial offset
        
        // Handle Window Resize
        window.addEventListener('resize', () => {
            width = document.getElementById('viz-container').offsetWidth;
            height = document.getElementById('viz-container').offsetHeight;
            if (d3Root) {
                update(d3Root);
            }
        });

        // Event Listeners
        document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        document.getElementById('searchInput').addEventListener('input', handleSearch);
    });

    // --- Data Processing ---
    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        document.getElementById('loading').style.display = 'flex';
        document.getElementById('file-status').textContent = file.name;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const rawData = JSON.parse(e.target.result);
                processData(rawData);
                document.getElementById('searchInput').disabled = false;
                document.getElementById('loading').style.display = 'none';
            } catch (err) {
                alert("Error parsing JSON: " + err.message);
                document.getElementById('loading').style.display = 'none';
            }
        };
        reader.readAsText(file);
    }

    function processData(data) {
        // 1. Build Metadata Map (RID -> Info)
        idToMeta = {};
        const count = data.rid.length;
        
        for (let idx = 0; idx < count; idx++) {
            // Ensure values exist
            if (data.rid[idx] !== undefined) {
                idToMeta[data.rid[idx]] = {
                    sid: data.sid && data.sid[idx] ? data.sid[idx] : `Unknown-${data.rid[idx]}`,
                    class_id: data.ilsvrc_class_id && data.ilsvrc_class_id[idx] !== undefined ? data.ilsvrc_class_id[idx] : -1
                };
            }
        }

        // 2. Build Tree Structure
        let visualRoot = { name: "World", children: [], rid: 0, class_id: -1 };
        
        if (data.path_rid) {
            for (let idx = 0; idx < data.path_rid.length; idx++) {
                const path = data.path_rid[idx];
                let currentLevel = visualRoot.children;
                
                for (let p = 0; p < path.length; p++) {
                    const rid = path[p];
                    
                    let existingNode = currentLevel.find(n => n.rid === rid);
                    
                    if (!existingNode) {
                        const meta = idToMeta[rid];
                        existingNode = {
                            rid: rid,
                            name: meta ? meta.sid : `Unknown (${rid})`,
                            class_id: meta ? meta.class_id : -1,
                            _children: null,
                            children: []
                        };
                        currentLevel.push(existingNode);
                    }
                    
                    currentLevel = existingNode.children;
                }
            }
        }

        if (visualRoot.children.length === 1) {
            rootData = visualRoot.children[0];
        } else {
            rootData = visualRoot;
        }

        initD3(rootData);
    }

    // --- D3 Visualization ---
    function initD3(data) {
        g.selectAll("*").remove(); // Clear canvas
        nodeLookup = {}; // Reset lookup

        d3Root = d3.hierarchy(data, d => d.children);
        
        // Calculate Statistics (Valid Classes / Total Nodes) using Sets for unique counting
        calculateStats(d3Root);

        d3Root.x0 = height / 2;
        d3Root.y0 = 0;

        // Pre-process to populate lookup for search
        d3Root.descendants().forEach(d => {
            if (!nodeLookup[d.data.rid]) nodeLookup[d.data.rid] = [];
            nodeLookup[d.data.rid].push(d);
            
            // Initial state: Collapse everything below depth 1
            if (d.depth > 1) {
                d._children = d.children;
                d.children = null;
            }
        });

        update(d3Root);
    }

    function calculateStats(node) {
        // Use Sets to track unique RIDs in this subtree to handle DAG nature
        const allRids = new Set();
        const validRids = new Set();

        // Add current node
        allRids.add(node.data.rid);
        if (node.data.class_id >= 0) {
            validRids.add(node.data.rid);
        }

        // Process children
        if (node.children) {
            node.children.forEach(child => {
                const childStats = calculateStats(child);
                
                // Merge child sets into current sets
                childStats.allRids.forEach(rid => allRids.add(rid));
                childStats.validRids.forEach(rid => validRids.add(rid));
            });
        }

        // Store counts
        node.data.statValid = validRids.size;
        node.data.statTotal = allRids.size;

        // Return sets up the tree
        return { allRids, validRids };
    }

    function update(source) {
        if (!source || !d3Root) return;

        const treeLayout = d3.tree().nodeSize([20, 180]); // Height, Width
        const treeData = treeLayout(d3Root);

        const nodes = treeData.descendants();
        const links = treeData.links();

        // Normalize for fixed-depth
        nodes.forEach(d => { d.y = d.depth * 220; }); // Increase horizontal spacing for numbers

        // ****************** Nodes section ***************************

        const node = g.selectAll('g.node')
            .data(nodes, d => d.id || (d.id = ++i));

        const nodeEnter = node.enter().append('g')
            .attr('class', d => {
                const type = d.data.class_id >= 0 ? 'node--class' : 'node--internal';
                return `node ${type}`;
            })
            .attr("transform", d => `translate(${source.y0},${source.x0})`)
            .on('click', click)
            .on('mouseover', showDetails);

        nodeEnter.append('circle')
            .attr('class', 'node-circle')
            .attr('r', 1e-6)
            .style("fill", d => d._children ? "#555" : (d.data.class_id >= 0 ? "#0d6efd" : "#fff"));

        // Text with stats
        const textEnter = nodeEnter.append('text')
            .attr("dy", ".35em")
            .attr("x", d => d.children || d._children ? -13 : 13)
            .attr("text-anchor", d => d.children || d._children ? "end" : "start")
            .style("fill-opacity", 1e-6);

        // Name
        textEnter.append("tspan")
            .text(d => d.data.name + " ");

        // Blue Number (Valid Classes)
        textEnter.append("tspan")
            .style("fill", "#0d6efd")
            .style("font-weight", "bold")
            .style("font-size", "0.9em")
            .text(d => d.data.statValid);

        // Separator and Total (Grey)
        textEnter.append("tspan")
            .style("fill", "#999")
            .style("font-size", "0.9em")
            .text(d => " / " + d.data.statTotal);

        // UPDATE
        const nodeUpdate = node.merge(nodeEnter);

        nodeUpdate.transition()
            .duration(duration)
            .attr("transform", d => `translate(${d.y},${d.x})`);

        nodeUpdate.select('circle.node-circle')
            .attr('r', d => d.data.class_id >= 0 ? 6 : 4.5)
            .style("fill", d => {
                if(d.data.selected) return "#dc3545"; 
                if(d.data.class_id >= 0) return "#0d6efd"; 
                return d._children ? "#999" : "#fff"; 
            })
            .style("stroke", d => d.data.selected ? "#842029" : (d.data.class_id >= 0 ? "#004085" : "#999"))
            .attr('cursor', 'pointer');

        // Update text position logic in case node moved from leaf to parent
        nodeUpdate.select('text')
            .transition().duration(duration)
            .attr("x", d => d.children || d._children ? -13 : 13)
            .attr("text-anchor", d => d.children || d._children ? "end" : "start")
            .style("fill-opacity", 1);

        // EXIT
        const nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", d => `translate(${source.y},${source.x})`)
            .remove();

        nodeExit.select('circle')
            .attr('r', 1e-6);

        nodeExit.select('text')
            .style("fill-opacity", 1e-6);

        // ****************** Links section ***************************

        const link = g.selectAll('path.link')
            .data(links, d => d.target.id);

        const linkEnter = link.enter().insert('path', "g")
            .attr("class", "link")
            .attr('d', d => {
                const o = {x: source.x0, y: source.y0};
                return diagonal(o, o);
            });

        const linkUpdate = link.merge(linkEnter);

        linkUpdate.transition()
            .duration(duration)
            .attr('d', d => diagonal(d.source, d.target));

        const linkExit = link.exit().transition()
            .duration(duration)
            .attr('d', d => {
                const o = {x: source.x, y: source.y};
                return diagonal(o, o);
            })
            .remove();

        nodes.forEach(d => {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    function diagonal(s, d) {
        return `M ${s.y} ${s.x}
                C ${(s.y + d.y) / 2} ${s.x},
                  ${(s.y + d.y) / 2} ${d.x},
                  ${d.y} ${d.x}`;
    }

    function click(event, d) {
        if (d.children) {
            d._children = d.children;
            d.children = null;
        } else {
            d.children = d._children;
            d._children = null;
        }
        update(d);
        showDetails(event, d);
    }

    // --- Interaction & Utils ---

    function showDetails(event, d) {
        const infoDiv = document.getElementById('node-info');
        const isClass = d.data.class_id >= 0;
        
        infoDiv.innerHTML = `
            <h6 class="text-dark">${d.data.name}</h6>
            <table class="table table-sm table-borderless small">
                <tr><td class="text-muted">RID:</td><td>${d.data.rid}</td></tr>
                <tr><td class="text-muted">Type:</td><td>
                    <span class="badge ${isClass ? 'bg-primary' : 'bg-secondary'}">
                        ${isClass ? 'ImageNet Class' : 'Internal Node'}
                    </span>
                </td></tr>
                ${isClass ? `<tr><td class="text-muted">Class ID:</td><td>${d.data.class_id}</td></tr>` : ''}
                <tr><td class="text-muted">Subtree Classes:</td><td class="text-primary fw-bold">${d.data.statValid}</td></tr>
                <tr><td class="text-muted">Subtree Nodes:</td><td>${d.data.statTotal}</td></tr>
            </table>
        `;
    }

    function handleSearch() {
        const rawQuery = document.getElementById('searchInput').value.toLowerCase();
        const query = rawQuery.trim();
        const resultsContainer = document.getElementById('search-results');
        const container = document.getElementById('search-results-container');
        const countBadge = document.getElementById('result-count');
        
        resultsContainer.innerHTML = '';
        
        if (query.length < 2) {
            container.style.display = 'none';
            return;
        }

        container.style.display = 'flex'; // Show container to indicate search is active
        const queryUnderscore = query.replace(/\s+/g, '_');
        const matches = [];

        for (const [rid, meta] of Object.entries(idToMeta)) {
            if (!meta || !meta.sid) continue; // Safety check
            
            const sid = meta.sid.toLowerCase();
            // Check for substring match on original or underscore-replaced query
            if (sid.includes(query) || (query !== queryUnderscore && sid.includes(queryUnderscore))) {
                matches.push({ rid: parseInt(rid), sid: meta.sid, cid: meta.class_id });
            }
        }

        countBadge.textContent = matches.length;

        // Sort matches for better relevance: 
        matches.sort((a, b) => {
            const aSid = a.sid.toLowerCase();
            const bSid = b.sid.toLowerCase();
            const q = queryUnderscore; 

            const aExact = aSid === q;
            const bExact = bSid === q;
            if (aExact && !bExact) return -1;
            if (!aExact && bExact) return 1;

            const aStart = aSid.startsWith(q);
            const bStart = bSid.startsWith(q);
            if (aStart && !bStart) return -1;
            if (!aStart && bStart) return 1;

            return aSid.localeCompare(bSid);
        });

        if (matches.length > 0) {
            matches.slice(0, 50).forEach(m => { // Limit to 50 items for perf
                const div = document.createElement('div');
                div.className = 'search-item';
                div.innerHTML = `<strong>${m.sid}</strong> <span class="text-muted text-xs">(${m.rid})</span>`;
                div.onclick = () => selectNode(m.rid);
                resultsContainer.appendChild(div);
            });
            
            if (matches.length > 50) {
                 const div = document.createElement('div');
                 div.className = 'p-2 text-center text-muted small fst-italic';
                 div.textContent = `... and ${matches.length - 50} more`;
                 resultsContainer.appendChild(div);
            }
        } else {
            const div = document.createElement('div');
            div.className = 'p-3 text-center text-muted';
            div.textContent = 'No matches found';
            resultsContainer.appendChild(div);
        }
    }

    function selectNode(rid) {
        const targets = nodeLookup[rid];
        if (!targets || targets.length === 0) {
            alert("Node found in metadata but not in the visualized tree.");
            return;
        }
        
        // 1. Reset previous selection
        d3Root.descendants().forEach(d => d.data.selected = false);

        // 2. Process ALL instances of this RID (DAG nature)
        // We iterate through all occurrences to highlight multiple paths
        targets.forEach(target => {
            // Mark as selected
            target.data.selected = true;

            // Expand ancestors for this specific instance so it becomes visible
            let ancestor = target.parent;
            while(ancestor) {
                if(ancestor._children) {
                    ancestor.children = ancestor._children;
                    ancestor._children = null;
                }
                ancestor = ancestor.parent;
            }
        });

        // 3. Update visualization to show expansions and red highlights
        update(d3Root);

        // 4. Zoom to the first instance found
        // Note: In a DAG, there might be multiple positions. We focus on the first one.
        const primaryTarget = targets[0];

        if (zoom && width && height) {
            const scale = 1.5;
            // Calculate center accounting for scale
            const transform = d3.zoomIdentity
                .translate(width / 2 - primaryTarget.y * scale, height / 2 - primaryTarget.x * scale)
                .scale(scale); 
            
            svg.transition().duration(750).call(zoom.transform, transform);
        }
        
        showDetails(null, primaryTarget);
    }

    function expandAll() {
        if(!d3Root) return;
        d3Root.descendants().forEach(d => {
            if(d._children) {
                d.children = d._children;
                d._children = null;
            }
        });
        update(d3Root);
    }

    function collapseAll() {
        if(!d3Root) return;
        d3Root.descendants().forEach(d => {
            if(d.depth > 0 && d.children) {
                d._children = d.children;
                d.children = null;
            }
        });
        update(d3Root);
    }
</script>
</body>
</html>
